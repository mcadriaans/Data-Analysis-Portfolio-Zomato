# -*- coding: utf-8 -*-
"""Zomato_EDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KzPp2kI30lY05VFMOooA2p5dc527nYVJ

>> <font size=6>Zomato Online Food Delivery Platform EDA
"""

from google.colab import drive
drive.mount('/content/gdrive')

"""# <font color=midnightblue><u>About the dataset</u>

##<font color=steelblue> Background

Zomato is a company that operates worldwide, with its headquarters in India. It **collects information about various restaurants** and presents it in a structured way on its platform. This allows users to browse different restaurants based on their preferences.

In addition to this, Zomato also offers a **food delivery service**.Users can order food from the restaurants listed on Zomato's platform, and Zomato will deliver the food to the users' specified location. This makes it convenient for users to enjoy meals from their favorite restaurants without leaving their homes or offices.

**Customers**:

> When customers order food from a restaurant through Zomato, they can trust that their food will be delivered quickly and reliably, which can enhance their overall experience and satisfaction with the restaurant. This, in turn, can contribute to the restaurant's growth and success. use the platform to search and find restaurants,write reviews and view and upload photos, order food delivery, book a table and make payments while dining-out at restaurants.

**Restaurants**:
>Zomato provides specific marketing resources to the restaurants that partner with them. These tools are designed to help these restaurants draw in new customers and keep their existing customers coming back by improving their services based on customer feedback.

>Zomato is centralized source for restaurants to obtain their supplies (eliminating having to deal with multiple vendors).The ingredients and kitchen products supplied are of high quality, ensuring that the restaurants can provide excellent food and service to their customers.

##<font color=steelblue>  Data Description

There are two datasets that will be merged on the country code into one dataset

> <u>Zomato</u>
* **Restaurant ID**: A unique identifier for each restaurant.
* **Restaurant Name**: The name of the restaurant.
* <font color=purple>**Country Code**</font>: The code representing the country where the restaurant is located.
* **City**: The city where the restaurant is located.
* **Address**: The physical address of the restaurant.
* **Locality**: The specific area or neighborhood where the restaurant is located within the city.
* **Locality Verbose**: A more detailed description of the restaurant's location, includes both the locality and the city.
* **Longitude**: The longitudinal coordinate of the restaurant's location.
* **Latitude**: The latitudinal coordinate of the restaurant's location.
* **Cuisines**: The types of cuisine offered by the restaurant.
* **Average Cost** for two: The average cost for two people to eat at the restaurant.
* **Currency**: The currency in which the restaurant's prices are listed.
* **Has Table booking**: Indicates whether the restaurant allows table reservations (Yes/No).
* **Has Online delivery**: Indicates whether the restaurant offers online food delivery (Yes/No).
* **Is delivering now**: Indicates whether the restaurant is currently delivering food (Yes/No).
* **Switch to order menu**: Indicates whether the feature that allows customers to switch to an order menu is available.
* **Price range**: The range of prices for the restaurant's offerings represented as a number 1 (Low), 2(Medium), 3(High), 4( Very High).
* **Aggregate rating**: The restaurant's overall rating, calculated from customer reviews.
* **Rating color**: A color-coded representation of the restaurant's rating. Colors are 'Dark Green' (Excellent), 'Green' (Very Good), 'Yellow' (Good), 'Orange'(Average), 'White' (Not Rated), 'Red'(Poor).
* **Rating text**: A text description of the restaurant's rating (e.g., Excellent, Good, Average, Poor).
* **Votes**: The number of votes the restaurant has received from customers.


> <u>Country</u>
* <font color=purple>**Country Code**</font>: The code representing the country where the restaurant is located.
* **Country**: The country where the restaurant is located

#<font size=11> <font color='midnightblue'><u>Working on the dataset</u>

##<font size=9><font color=steelblue>Load the data

###<font size=6><font color=indigo>**Dependencies**
"""

import numpy as np
import pandas as pd


import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objs as go

import plotly.subplots as sp

import folium
from folium.plugins import HeatMap

"""###<font size=6><font color=indigo>**Datasets**"""

## Load the zomato dataset (data related to restaurants on the zomato online food delivery platform)
data_zmt = pd.read_csv('/content/gdrive/MyDrive/Python/Python_Data_Analysis_Projects/Zomato_Food_Delivery/data/zomato.csv', encoding='latin-1')
#data_zmt.head(2)

## Load the country codes dataset
data_ctry = pd.read_excel('/content/gdrive/MyDrive/Python/Python_Data_Analysis_Projects/Zomato_Food_Delivery/data/country.xlsx')
#data_ctry

"""##<font size=9><font color=steelblue>Understanding the data

###<font size=6><font color=indigo>**Dimensions of the datasets**
"""

# Dimensionality of the dataFrame
data_zmt.shape

"""* There are 9551 restaurants listed in the dataset with 21 distinguishing attributes."""

# Dimensionality of the dataFrame
data_ctry.shape

"""* There are 15 different countries represented in the data.

###<font size=6><font color=indigo>**Dataset Information**

```
* range index
* number of columns
* column labels
* the number of cells in each column (non-null values)
* column data types
* memory usage
```
"""

data_zmt.info()

data_ctry.info()

"""* Both datasets have a common column `Country Code` on which
* There are missing values in the zomato dataset.

##<font size=9><font color=steelblue>Data Cleaning

###<font size=6><font color=indigo>**Joining the datasets**
"""

data = pd.merge(data_zmt, data_ctry, on = 'Country Code')
#data.shape

"""###<font size=6><font color=indigo>**Rename Fields**

```
Changing the field names to lowercase with underscores can improve readability.
```
"""

## Convert all column names in data to lowercase and replace whitespace with underscore
data.columns = data.columns.str.lower().str.replace(' ', '_')
data.columns

"""###<font size=6><font color=indigo> **Fill Missing Values**"""

## Return the columns that have missing values
print([cols for cols in data.columns if data[cols].isnull().sum() > 0])

## Return the count of all null values in `Cuisines`
print(data['cuisines'].isnull().sum())

cuisines_missing_perc = data['cuisines'].isnull().sum()/data.shape[0]
print('{:.2f}%'.format(cuisines_missing_perc))

"""

* `cuisines` has 9 missing values which are negligible. We can replace them.
* `cuisines` is of type string so we can replace missing values with 'Other'"""

## Fill the missing values with value
data['cuisines'] = data['cuisines'].fillna(value='Other')

df = data.copy()

"""##<font size=9><font color=steelblue>Exploratory Data Analysis

###<font size=6><font color=indigo>**Geographical Analysis**

#### <font size=5><font color=blue>**What is the country with the highest ratings?**
"""

df_country = df.groupby(['country']).size().reset_index(name='counts').sort_values(by='counts', ascending=False)
df_country['restaurant_%'] = (df_country['counts']/df_country['counts'].sum())*100

df_country.loc[df_country['restaurant_%'] < 3, 'country'] = 'Other'
df_ctr= df_country.groupby('country')[['counts', 'restaurant_%']].sum().reset_index()
df_ctr

fig = px.pie(df_ctr, values='counts', names='country', hole=0.5)
fig.update_layout(
    autosize=False,
    title=dict(
        text='Proportion of Total Restaurants',
        x=0.5,
        y=0.93
    ),
    legend=dict(
        title='Country',
        x=0.8,
        y=0.9
    )
)
fig.show()

"""#####<font size=4>**Countries with top ratings**"""

df['rating_text'].unique()

df_excellent_ratings = df[df['rating_text'] == 'Excellent']
df_ctry_excellent_counts = df_excellent_ratings['country'].value_counts().reset_index()
df_ctry_excellent_counts.columns = ['country','count']
df_ctry_excellent_counts['ratings_perc_total'] = round(df_ctry_excellent_counts ['count'] /df_ctry_excellent_counts ['count'].sum(),2)
#df_ctry_excellent_counts

## Specify initial center coordinates and zoom level
basemap = folium.Map(location=[0, 0], zoom_start=2, prefer_canvas=True)


fig = px.choropleth(df_ctry_excellent_counts, locations='country',
                    color='count', # column to use to set color
                    hover_name='country', # column to add to hover information
                    hover_data=['ratings_perc_total', 'count'], # update hover data
                    color_continuous_scale=px.colors.sequential.YlOrRd, # set color scale
                    locationmode='country names') # specify the field to match the country name
fig.update_traces(
    hovertemplate='<b>%{hovertext}</b><br>Ratings Per Total: %{customdata[0]:.0%}<br>Nr. of Ratings: %{customdata[1]}')
    #customdata is specified in hover_data, it follows the sequence when assigning


fig.update_layout(
    title=dict(
        text= 'Distribution of Top-Rated Restaurants Across Countries',
        x = 0.5,
        y = 0.93
    ),
    coloraxis_colorbar=dict(
        title="Nr. of Ratings",
        x=0.86 # Adjust this value to move the colorbar
    )
)

fig.show()

"""#####<font size=4>**Average Aggregate Ratings Across Countries**


"""

## Average aggregate rating per country
df_ctry_rating = df.groupby(['country'])['aggregate_rating'].mean().reset_index().sort_values(by='aggregate_rating', ascending=False)

## Create a bar chart
fig=px.bar(df_ctry_rating , x='country', y='aggregate_rating',  color='country')

## Update the hover template for all traces
fig.update_traces(
    hovertemplate='%{x}<br>Average Overall Restaurant Rating: %{y:.2f}'
)
## Modify layout
fig.update_layout(
    showlegend=False,
    title=dict(
        text='Comparision of Average Aggregate Ratings Across Countries',
        x=0.5,
        y=0.93
    ),
    xaxis_title='Country',
    yaxis_title='Average Aggregate Rating'
)
fig.show()

"""<font size=5>☝<font color=darkcyan><u>**Observations**:</u></font>

><font color=darkcyan>India accounts for 90.6% of all restaurants in the dataset and therefore has the most number of top ratings.

><font color=darkcyan>The Philippines holds the top position in terms of overall average rating amongst all the countries.

<font size=4>⚡<font color=darkcyan>***When considering the quality of ratings, the Philippines has the highest ranking***.

####<font size=5><font color=blue>**What are the most successful restaurants in India?**

#####<font size=4>**Restaurants Across Cities in India**
"""

#df.columns

df_india = df[df['country'] == 'India']

df_cty_restaurants = df_india.groupby(['city']).size().reset_index(name='nr_of_restaurants')
df_cty_restaurants.sort_values(by='nr_of_restaurants', ascending=False, inplace=True)
#df_cty_restaurants

fig = px.bar(df_cty_restaurants, x='city', y='nr_of_restaurants', color='city')

fig.update_layout(
    title=dict(
        text= 'Distribution of Restaurants Across Cities in India',
        x=0.5,
        y=0.93
    ),
    xaxis_title = 'City',
    yaxis_title = 'Nr. of Restaurants',
    legend = dict(
        title='City'
    )
)
fig.show()

"""#####<font size=4>**Top-rated, Popular Restaurants Across Cities in India**"""

## Define success as having a high aggregate rating and a high number of votes
df_successful = df_india[(df_india['aggregate_rating']> 4) & (df_india['votes']> 100)]

df_cty_successful = df_successful.groupby(['city']).size().reset_index(name='nr_of_restaurants')
df_cty_successful.sort_values(by='nr_of_restaurants', ascending=False, inplace=True)

fig = px.bar(df_cty_successful, x='city', y='nr_of_restaurants', color='city')

fig.update_layout(
    title=dict(
        text= 'Distribution of Top-Rated  and Popular Restaurants Across Cities in India',
        x=0.5,
        y=0.93
    ),
    xaxis_title = 'City',
    yaxis_title = 'Nr. of Restaurants',
    legend = dict(
        title='City'
    )
)
fig.show()

"""<font size=5>☝<font color=darkcyan><u>**Observations**:</u></font>

><font color=darkcyan>New Delhi , Gurgaon, Noida are the top three cities that have the most restaurants, are top-rated and most popular out of all the cities in India.

><font color=darkcyan>Bangalore and Pune both only have 20 restaurants but they rank in the top 5 with regards to top ratings and popularity.

<font size=4>⚡<font color=darkcyan>***New Delhi is the city with the most successful restaurants in India***.

###<font size=6><font color=indigo>**Price Analysis**

####<font size=5><font color=blue>**Do more expensive restaurants receive more votes?**

#####<font size=4>**Votes Across Price Categories**
"""

#df['price_range'].dtypes

## Find the total number of votes for each price range
df_price_votes = df.groupby(['price_range'])['votes'].sum().reset_index()
#df_price_votes

## Define categories for each price range and replace the original values

mapping = { 1: 'Economical',
            2: 'Mid-Range',
            3: 'Upscale',
            4: 'Fine Dining'}

df_price_votes['price_range'] = df_price_votes['price_range'].map(mapping)

fig  = px.bar(df_price_votes , x = 'price_range', y='votes', color='price_range')
              #color_discrete_sequence=['indigo', 'magenta', 'purple','orchid'])

fig.update_traces(
  hovertemplate='Votes counted: %{y}'
)

fig.update_layout(
    autosize=False,
    title=dict(
        text='Comparing Vote Counts Among Price Categories',
        x = 0.5,
        y = 0.93
    ),
    legend=dict(
        title='Price Categories'
    ),
    xaxis_title='Price Categories',
    yaxis_title = 'Vote Count'
)
fig.show()

"""#####<font size=4>**Restaurants Across Price Categories**"""

df_price_rest = df.groupby(['price_range']).size().reset_index()
df_price_rest.columns = ['price_range', 'count']

mapping = {
    1: 'Economical Eats',
    2: 'Mid-Range Dining',
    3: 'Upscale Cuisine',
    4: 'Fine Dining'
}

df_price_rest['price_range'] = df_price_rest['price_range'].map({1: 'Economical Eats',
                                                                 2: 'Mid-Range Dining',
                                                                 3: 'Upscale Cuisine',
                                                                4: 'Fine Dining'})
#df_price_rest

fig = px.pie(df_price_rest , values='count',names='price_range', hole=0.5,
             #color_discrete_sequence=['indigo', 'magenta', 'purple','orchid'],
             hover_name = 'price_range',
             hover_data=['count'])


fig.update_traces(
    hovertemplate='<b>%{hovertext}</b><br>Total Restaurants: %{customdata[0]}'

)

fig.update_layout(
    autosize=False,
    title = dict(
        text = 'Distribution of Total Restaurants by Price Category',
        x = 0.4,
        y=0.93
    ),
    legend = dict(
        title ='Price Category',
        x=0.8,
        y=0.9
    )
)

fig.show()

"""<font size=5>☝<font color=darkcyan><u>**Observations**:</u></font>

<font color=darkcyan>In the process of analyzing the vote count across different price ranges, it’s crucial to consider the total number of restaurants within each category. When we adjust for the number of restaurants, it becomes evident that restaurants in the 3rd (Upscale Cuisine) and 4th (Fine Dining) price ranges, despite constituting a smaller fraction of the total number of restaurants, garner a higher number of votes.

<font size=4>⚡<font color=darkcyan>***Restaurants with higher prices tend to attract more votes***.

####<font size=5><font color=blue>**Which of the top 10 restaurants with the most outlets has the biggest fluctuation in prices?**

#####<font size=4>**Top 10 Indian Restaurants with the most outlets**
"""

#df.columns

## Only restaurants in India
df_india = df[df['country'] == 'India']

# Filter the data for the required columns
df_india_ra = df_india[['restaurant_name', 'average_cost_for_two']]

## Find the nr. of outlets for each restaurant in India
df_india_outlets = df_india.groupby('restaurant_name').size().reset_index(name='nr_of_outlets')
## Sort by ascending nr of outlets
df_india_outlets.sort_values(by='nr_of_outlets', ascending=False, inplace=True)
## Find top 10 restaurants with the most outlets
top_10_indian_outlets = df_india_outlets.reset_index(drop=True).head(10)
top_10_indian_outlets

fig = px.bar(top_10_indian_outlets, x='nr_of_outlets', y='restaurant_name', orientation='h', color='restaurant_name')


fig.update_traces(
    hovertemplate='Total Outlets: %{x}')


fig.update_layout(
    autosize=False,
    title=dict(
        text='Distribution of Top 10 Indian Restaurants with the most Outlets',
        x=0.5,
        y=0.93
    ),
    legend=dict(
        title='Restaurant'
    ),
    xaxis_title = 'Number of Outlets',
    yaxis_title='Restaurants'

)

fig.show()

"""#####<font size=4>**Average Cost for Two Customers From Top 10 Indian Restaurants with the most outlets**"""

# Find the top 10 restaurants with the most outlets
top_10_restaurants =df_india_ra['restaurant_name'].value_counts().nlargest(10).index
top_10_restaurants


## Filter the data for these top 10 restaurants
df_top_10 = df_india_ra[df_india_ra['restaurant_name'].isin(top_10_restaurants)]


fig = px.box(df_top_10, x='restaurant_name', y='average_cost_for_two', color='restaurant_name')
fig.update_layout(
    title=dict(
        text='Average Cost for Two at Top 10 Indian Restaurants with Most Outlets',
        x=0.5,
        y=0.93
    ),
    legend=dict(
        title='Restaurant'
    ),
    xaxis_title=('Restaurant'),
    yaxis_title=('Average Cost for Two')
)
fig.show()

"""<font size=5>☝<font color=darkcyan><u>**Observations**:</u></font>

><font color=darkcyan>**Pizza Hut**  shows some variation in prices, but to a lesser extent than **Barbeque Nation**.

><font color=darkcyan>**McDonald's, Subway, Domino's Pizza, Green Chick Chop, Cafe Coffee Day, Giani, Keventers, Baskin Robbins**: These restaurants are represented by single markers indicating specific average costs. This suggests that there are no noticeable fluctuations in their prices.

<font size=4>⚡<font color=darkcyan>***Barbecue Nation exhibits the greatest price variation among the top 10 Indian restaurants. This indicates that the average cost for two at Barbecue Nation can vary more widely than at other comparable restaurants.***

________________________________________________________________________________

###<font size=6><font color=indigo>**Restaurant Performance**

####<font size=5><font color=blue>**How does online ordering availability impact restaurant ratings and popularity?**

#####<font size=4>**Restaurants for Each Online Delivery Option**
"""

df_d = df.groupby(['has_online_delivery']).size().reset_index(name='count')

fig = px.pie(df_d, values='count', names='has_online_delivery', hole=0.5)
fig.update_layout(
    autosize=False,
    title=dict(
        text='Proportion of Restaurants Based on Delivery Availability',
        x=0.5,
        y=0.93
    ),
    legend=dict(
        title='Online Delivery Availability',
        x=0.8,
        y=0.9
    )
)
fig.show()

"""#####<font size=4>**Customer Votes Based on Online Delivery Availability**"""

df['votes'].describe()

fig = px.box(df, x='has_online_delivery', y='votes', color='has_online_delivery')
fig.update_layout(
    autosize=False,
     title=dict(
        text='Comparison of Customer Votes Based on Online Delivery Availability',
        x=0.5,
        y=0.93
    ),
    legend=dict(
        title='Online Delivery Availability',

    ),
   xaxis_title='Online Delivery Availability',
   yaxis_title='Aggregate Rating'
)
fig.update_yaxes(range=[0, 1000])
fig.show()

"""#####<font size=4>**Aggregate Ratings Distributions for Online Delivery Availability Options**"""

fig = px.box(df, x='has_online_delivery', y='aggregate_rating', color='has_online_delivery')
fig.update_layout(
    autosize=False,
     title=dict(
        text='Comparison of Aggregate Ratings Based on Online Delivery Availability',
        x=0.5,
        y=0.93
    ),
    legend=dict(
        title='Online Delivery Availability',

    ),
   xaxis_title='Online Delivery Availability',
   yaxis_title='Aggregate Rating'
)
fig.show()

"""#####<font size=4>**The Relationship between Ratings and Votes based on Online Delivery Availability**"""

## Show the average votes for a combination of online availability and aggregate rating
df_d1 = df.groupby(['has_online_delivery', 'aggregate_rating'])['votes'].mean().reset_index(name='avg_votes_per_rating')

fig = px.scatter(df_d1, x='aggregate_rating', y='avg_votes_per_rating', color='has_online_delivery')

fig.update_traces(
    hovertemplate='<b>Rating:%{x}</b><br>Average Customer Votes: %{y}'

)
fig.update_layout(
   autosize=False,
   title=dict(
       text='Impact of Online Delivery on Restaurant Ratings and Customer Votes',
       x=0.5,
       y=0.93
   ),
   legend=dict(
       title='Online Delivery'
   ),
   xaxis_title=('Aggregate Rating'),
   yaxis_title=('Average Number of Votes')
)

fig.show()

# Calculate correlation for all restaurants
correlation_all = df['aggregate_rating'].corr(df['votes'])

# Calculate correlation for restaurants with online delivery
correlation_delivery = df[df['has_online_delivery'] == 'Yes']['aggregate_rating'].corr(df['votes'])

# Calculate correlation for restaurants without online delivery
correlation_no_delivery = df[df['has_online_delivery'] == 'No']['aggregate_rating'].corr(df['votes'])

#print("Correlation (All): ", correlation_all)
#print("Correlation (With Delivery): ", correlation_delivery)
#print("Correlation (Without Delivery): ", correlation_no_delivery)

"""| Category | Correlation |
| --- | --- |
| All Restaurants | 0.31 |
| Restaurants with Delivery | 0.29 |
| Restaurants without Delivery | 0.33 |

<font size=5>☝<font color=darkcyan><u>**Observations**:</u></font>


><font color=darkcyan>Restaurants that offer online delivery received a significantly higher number of votes, despite the fact that the majority of restaurants do not offer online delivery.

><font color=darkcyan>Restaurants that offer online delivery tends to have higher aggregate ratings compared to those that do not. The variability in non-delivery restaurants is higher, which can be attributed to the majority of restaurants not offering online delivery.

><font color=darkcyan>Restaurants with online delivery service typically get higher ratings and, on average, accumulate more votes compared to those without the service.Availability of online delivery could play a crucial role in a restaurant's appeal and customer satisfaction.

><font color=darkcyan>There is a weak positive correlation between aggregate ratings and the number of votes for all restaurants, regardless of online delivery availability. This suggests that restaurants with higher ratings tend to attract more votes, but the relationship is not very strong.

<font size=4>⚡<font color=darkcyan>***Restaurants with higher ratings tend to have more votes, regardless of whether they offer online delivery or not. However,the availability of online delivery could be a significant factor in a restaurant's popularity and customer satisfaction. It seems to influence both the number of votes a restaurant receives and its aggregate rating.***

_______________________________________________________________________________
"""